\documentclass[12pt]{article}
\usepackage{epsfig}
\usepackage{color}
\pagecolor{white}
\setlength{\textwidth}{7in}
\setlength{\oddsidemargin}{-0.5in}
\setlength{\evensidemargin}{-0.5in}
\usepackage{listings}
\lstset{
  basicstyle=\ttfamily,
  mathescape
} 

\title{Zebu Specification}

\begin{document}
\maketitle

\section{Overview}

Zebu is meant to be a parser generator for the Go language, with it's primary focus being the ability to extend other grammars written in Zebu.

Yacc/Bison, ATNLR, and PPG (Polyglot Parser Generator) serve as inspirations for how Zebu should function, with features pulled from each. 

\subsection{Why Zebu?}

Yacc/Bison laid the groundwork and serve as the model for compiler compilers in the field. Although there are implementations in Go, the syntax is a little outdated and does not feature the main motivation behind Zebu, the ability to extend grammars.

ANTLR serves as a great model for the syntactic design of a modern compiler compiler, but again is missing (and was not designed) the ability to extend grammars. This is not a flaw in ANTLR, but a unique need that requires a specific implementation.

PPG has most of the features that are required to extend a grammar (as that is what it is designed for) but lacks some of the power that is needed to fully extend a grammar.

Zebu is needed to resolve the three above compiler compilers into one that serves a specific purpose, the ability to fully extend grammars.

\subsection{Goals}

The main goal of Zebu is to generate extensible grammars, as such there will be design tradeoffs versus other compiler compilers. 

Zebu highlights...

\begin{itemize}

\item Combine lexicon and grammar into one definition similar to ANTLR. The lexicon will be defined with regular definitions. The parser should be defined with a context free grammar.

\item Unlike ANTLR, only regular definitions can serve as terminal symbols in the grammar. This is to enforce a consistent style (no mixing regular expressions, regular efinitions, and grammar rules).

\item Regular definitions as well as grammar rules will be subject to the same extensible syntax and semantics. This allows extending grammars to override not only the semantics of a grammar, but the syntax as well.

\item Generate LL(1) recursive decent parsers that can handle direct and indirect left recursion. The generated parser should be readable by humans.

\item No global variables, Zebu should expose a parser object and mechanisms to modify this object. The API Zebu exposes should be operations on this object.

\item No parse tree generation. ANTLR parse tree is very useful, but eventually an AST needs to be generated, and thus we have to revert to semantic actions anyways.

\end{itemize}

\subsection{Extention Features}

All definitions (regular definitions and grammar rules) are subject to the same extensible syntax and semantics. The expected extention rules are...

\begin{itemize}

\item \textbf{extend} : Add new productions to an existing production in the grammar.

\item \textbf{inherit} : Copy and existing production and use it to define a new production. Similar to extend, but the origin production is not modified.

\item \textbf{override} : Replace a production in the grammar.

\item \textbf{delete} : Remove a production from a grammar.

\end{itemize}

\section{Zebu Language}

\subsection{Reserved Words}
Zebu reserves the following identifiers for use as keywords.

\begin{center}
\begin{tabular}{c c c c}
\textbf{grammar} & \textbf{import} & \textbf{keyword} & \textbf{extend}   \\
\textbf{inherit} & \textbf{override} & \textbf{delete}                    \\
\end{tabular}
\end{center}

\subsection{Regular Definitions}

Regular definitions have the following format and semantic restrictions.

\begin{verbatim}
Head : Body ;
\end{verbatim}

\begin{itemize}

\item The head of a regular definitions must begin with an uppercase character and may be followed by zero or more alphanumeric characters. This is done to ease parsing and enforce a style on the actual grammar definition.

\item The body of a regular definition may contain any valid unicode character, previously defined regular definition, and regular definition operator.

\item The standard dot (.) represents any valid unicode character.

\item The regular definition operators are defined as
  \begin{itemize}
    \item \textbf{X*} : Match X zero or more times
    \item \textbf{X+} : Match X zero or more times
    \item \textbf{X\textbar Y} : Match X or Y
    \item \textbf{(X)}  : Group X to form an inline regular definition.
    \item \textbf{X\{r\}}  : Match X r times, where r is a range defined as 
      \begin{itemize}
        \item \{m\} : Match exactly m times
        \item \{m,n\} : Match m through n times
        \item \{,n\} : Match up to n times
        \item \{m,\} : Match at least m times
      \end{itemize}
    \item \textbf{\textasciicircum X} : Match anything \textbf{but} X.
    \item \textbf{[X Y Z]} : Match either X, Y, or Z. Spaces are optional for unicode characters, but necessary when using regular definitions.
    \item \textbf{[X-Y]}  : Match any unicode character between X and Y, including both. The range operator \textbf{can not} be used on regular definitions.
  \end{itemize}

\item Backslash escapes regular definition operators, and is used to access the setup of predefined regular definitions. The set includes
  \begin{itemize}
    \item \textbackslash s : Any whitespace character except newline.
    \item \textbackslash n : Newline.
  \end{itemize}

\end{itemize}

The following is a Zebu grammar describing regular expressions as recognized by Zebu.

\begin{verbatim}

grammar regular_definition;

RegDefStart : [A-Z] ;
RegDefPart  : .     ;

RegDefHead  : RegDefStart RegDefPart* ;

OpDot           : \.  ;
OpComma         : ,   ;
OpStar          : \*  ;
OpPlus          : \+  ;
OpBar           : \|  ;
OpCircum        : \^  ;
OpLeftParan     : \(  ;
OpRightParan    : \)  ;
OpLeftBrace     : \{  ;
OpRightBrace    : \}  ;
OpLeftBracket   : \[  ;
OpRightBracket  : \]  ;
OpRange         : -   ;

\end{verbatim}

\end{document}
